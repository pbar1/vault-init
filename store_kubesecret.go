package main

import (
	"context"
	"encoding/json"

	vaultapi "github.com/hashicorp/vault/api"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

const StoreKubeSecret = "kube-secret"

func storeKubeSecret(response *vaultapi.InitResponse) error {
	initJSON, err := json.Marshal(response)
	if err != nil {
		return err
	}

	config, err := rest.InClusterConfig()
	if err != nil {
		return err
	}
	kube, err := kubernetes.NewForConfig(config)
	if err != nil {
		return err
	}

	// to avoid losing vault init data: if secret with desired name already exists, use it as prefix for autogenerated secret name instead
	metadata := metav1.ObjectMeta{
		Labels:      *flagKubeSecretLabels,
		Annotations: *flagKubeSecretAnnotations,
	}
	if existing, err := kube.CoreV1().Secrets(*flagKubeSecretNamespace).Get(context.TODO(), *flagKubeSecretName, metav1.GetOptions{}); err == nil && existing.Name == *flagKubeSecretName {
		metadata.GenerateName = *flagKubeSecretName
	} else {
		metadata.Name = *flagKubeSecretName
	}

	// create the secret
	if _, err = kube.CoreV1().Secrets(*flagKubeSecretNamespace).Create(context.TODO(), &corev1.Secret{
		ObjectMeta: metadata,
		Data: map[string][]byte{
			"init.json":  initJSON,
			"root_token": []byte(response.RootToken),
		},
	}, metav1.CreateOptions{}); err != nil {
		return err
	}

	return nil
}
