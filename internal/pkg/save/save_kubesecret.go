package save

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	vaultapi "github.com/hashicorp/vault/api"
	"github.com/rs/zerolog/log"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/clientcmd/api"
)

// KubeSecretSaveMethod saves and loads a Vault init response to a Kubernetes secret.
type KubeSecretSaveMethod struct {
	kube *kubernetes.Clientset

	// Overwrite allows the Kubernetes secret to be updated in place.
	Overwrite bool

	// KubeconfigPath is a path to the Kubeconfig to use for connecting to the Kubernetes API.
	KubeconfigPath string

	// SecretName is the name of the Kubernetes secret to read and write the Vault init response.
	SecretName string

	// SecretNamespace is the Kubernetes namespace where the secret resides.
	SecretNamespace string

	// SecretAnnotations is a map of metadata annotations that will be applied to the secret.
	SecretAnnotations map[string]string

	// SecretLabels is a map of metadata labels that will be applied to the secret.
	SecretLabels map[string]string

	// InitResponseKey is the key in the Kubernetes secret where the Vault init response JSON payload will be stored.
	InitResponseKey string

	// RootTokenKey is the key in the Kubernetes secret where the Vault root token will be stored.
	RootTokenKey string
}

const SaveKubeSecret = "kube-secret"

// NewKubeSecretSaveMethod constructs a KubeSecretSaveMethod from a secret name and any functional options, builds a
// Kubernetes API client, and sets the namespace.
func NewKubeSecretSaveMethod(secretName string, options ...func(*KubeSecretSaveMethod)) (*KubeSecretSaveMethod, error) {
	l := log.With().Str("secretName", secretName).Logger()

	m := KubeSecretSaveMethod{SecretName: secretName}

	// apply functional options
	for _, option := range options {
		option(&m)
	}

	kube, err := newKubeClient(m.KubeconfigPath)
	if err != nil {
		l.Error().Err(err).Msg("failed to create kubernetes api client")
		return nil, err
	}
	m.kube = kube

	// set kubernetes namespace if possible, else fall back to the default namespace
	if m.SecretNamespace == "" {
		nsBytes, err := os.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace")
		if err != nil {
			l.Warn().Err(err).Msg("unable to read namespace, falling back to default")
			m.SecretNamespace = "default"
		} else {
			m.SecretNamespace = string(nsBytes)
		}
		l.Info().Msg("read namespace from kubernetes service account volume mount")
	}
	l = l.With().Str("secretNamespace", m.SecretNamespace).Logger()
	l.Info().Msg("set namespace")

	if m.InitResponseKey == "" {
		m.InitResponseKey = DefaultInitResponseKey
	}
	if m.RootTokenKey == "" {
		m.RootTokenKey = DefaultRootTokenKey
	}

	return &m, nil
}

// Save writes a Vault init response to its configured Kubernetes secret, and returns the secret's location in the
// string form `{{ namespace }}/{{ name }}`.
func (m *KubeSecretSaveMethod) Save(response *vaultapi.InitResponse) (string, error) {
	l := log.With().Str("secretName", m.SecretName).Str("secretNamespace", m.SecretNamespace).Logger()

	initJSON, err := json.Marshal(response)
	if err != nil {
		l.Error().Err(err).Msg("failed to json marshal VaultClient init response")
		return "", err
	}

	// to avoid losing VaultClient init data: if secret with desired name already exists,
	// use it as prefix for autogenerated secret name instead
	metadata := metav1.ObjectMeta{
		Labels:      m.SecretLabels,
		Annotations: m.SecretAnnotations,
	}
	exists := true
	_, err = m.kube.CoreV1().Secrets(m.SecretNamespace).Get(context.TODO(), m.SecretName, metav1.GetOptions{})
	if err != nil && strings.Contains(err.Error(), "not found") {
		exists = false
	} else if err != nil {
		l.Error().Err(err).Msg("failed to determine if secret already exists")
		return "", err
	}
	if !exists || m.Overwrite {
		metadata.Name = m.SecretName
	} else {
		l.Warn().Err(err).Msg("existing secret found and cannot overwrite, using name prefix instead")
		metadata.GenerateName = fmt.Sprintf("%s-", m.SecretName)
	}
	secret := &corev1.Secret{
		ObjectMeta: metadata,
		Data: map[string][]byte{
			m.InitResponseKey: initJSON,
			m.RootTokenKey:    []byte(response.RootToken),
		},
	}

	// upsert the kubernetes secret
	var secretResp *corev1.Secret
	if exists {
		secretResp, err = m.kube.CoreV1().Secrets(m.SecretNamespace).Update(context.TODO(), secret, metav1.UpdateOptions{})
	} else {
		secretResp, err = m.kube.CoreV1().Secrets(m.SecretNamespace).Create(context.TODO(), secret, metav1.CreateOptions{})
	}
	if err != nil {
		l.Error().Err(err).Msg("failed to create or update secret")
		return "", err
	}

	return fmt.Sprintf("%s/%s", secretResp.Namespace, secretResp.Name), nil
}

// Load reads a Vault init response from its configured Kubernetes secret.
func (m *KubeSecretSaveMethod) Load() (*vaultapi.InitResponse, error) {
	l := log.With().Str("secretName", m.SecretName).Str("secretNamespace", m.SecretNamespace).Logger()

	secret, err := m.kube.CoreV1().Secrets(m.SecretNamespace).Get(context.TODO(), m.SecretName, metav1.GetOptions{})
	if err != nil {
		l.Error().Err(err).Msg("failed to get secret")
		return nil, err
	}

	initJSON, found := secret.Data[m.InitResponseKey]
	if !found {
		log.Error().Str("initResponseKey", m.InitResponseKey).Msg("init response not found in secret")
		return nil, err
	}
	l.Trace().Bytes("initJSON", initJSON).Msg("read secret contents")

	response := new(vaultapi.InitResponse)
	if err := json.Unmarshal(initJSON, response); err != nil {
		l.Error().Err(err).Msg("failed to json unmarshal VaultClient init response")
		return nil, err
	}
	l.Trace().Interface("response", response).Msg("json unmarshalled VaultClient init response")

	return response, nil
}

// newKubeClient creates a Kubernetes API client from a kubeconfig file. If no file is passed, falls back to InClusterConfig.
func newKubeClient(kubeconfigPath string) (*kubernetes.Clientset, error) {
	l := log.With().Str("kubeconfigPath", kubeconfigPath).Logger()

	var config *rest.Config
	var err error
	if kubeconfigPath == "" {
		config, err = rest.InClusterConfig()
		if err != nil {
			l.Error().Err(err).Msg("failed to load inclusterconfig")
			return nil, err
		}
	} else {
		config, err = clientcmd.BuildConfigFromKubeconfigGetter("", func() (*api.Config, error) {
			return clientcmd.LoadFromFile(kubeconfigPath)
		})
		if err != nil {
			l.Error().Err(err).Msg("failed to load kubeconfig from file")
			return nil, err
		}
	}
	l.Trace().Interface("config", config).Msg("loaded kubernetes api client configuration")

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		l.Error().Err(err).Msg("failed to create kubernetes api client")
		return nil, err
	}
	l.Trace().Interface("clientset", clientset).Msg("created kubernetes api client")

	return clientset, nil
}
